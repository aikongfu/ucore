刚开始

(gdb) i r cs eip
cs             0x0      0
eip            0x7c00   0x7c00

b *0x7c00
0x7c00
0x7c00  cli                                                                                                   │
0x7c01  cld                                                                                                   │
0x7c02  xor    %ax,%ax                                                                                        │
0x7c04  mov    %ax,%ds                                                                                        │
0x7c06  mov    %ax,%es                                                                                        │
0x7c08  mov    %ax,%ss 


刚开始时是：
GDT 00000000 0000FFFF
IDT 00000000 0000FFFF

执行到0x7c00时
GDT 00F6C000 00000037
IDT 00000000 000003FF

0x7c57:      jne    0x7c2d
0x7c59:      lgdtw  0x7dac


执行完lgdt gdtdesc后
eax            0x534d4150       1397571920
ecx            0x14     20
edx            0x534d4150       1397571920
ebx            0x0      0
esp            0x6f2c   0x6f2c
ebp            0x0      0x0
esi            0x0      0
edi            0x807c   32892
eip            0x7c5e   0x7c5e
eflags         0x46     [ PF ZF ]
cs             0x0      0
ss             0x0      0
ds             0x0      0
es             0x0      0
fs             0x0      0
gs             0x0      0


# Bootstrap GDT
.p2align 2                                          # force 4 byte alignment
gdt:
    SEG_NULLASM                                     # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel

gdtdesc:
    .word 0x17                                      # sizeof(gdt) - 1
    .long gdt                                       # address gdt


执行完lgdt gdtdesc后
GDT 00007D94 00000017
IDT 00000000 000003FF

GDT
0x7d94: 0x00000000      0x00000000      0x0000ffff      0x00cf9a00
0x7da4: 0x0000ffff      0x00cf9200      0x7d940017      0x00000000
0x7db4: 0x00000000      0x00000000

可以看到全局描述符表一共三条：
|----------|---------------------------------------|
|0x00000000|0000 0000 0000 0000 0000 0000 0000 0000|按照x86的设计，第0项均为0
|0x00000000|0000 0000 0000 0000 0000 0000 0000 0000|
|----------|---------------------------------------|
|0x00cf9a00|0000 0000 1100 1111 1001 1010 0000 0000|base = 0, limit = 0xFFFFF (1048575)1111 1111 1111 1111 1111
|0x0000ffff|0000 0000 0000 0000 1111 1111 1111 1111|type = 1010, 代码段的TYPE为：1010（执行、读）
|----------|---------------------------------------|
|0x00cf9200|0000 0000 1100 1111 1001 0010 0000 0000|base = 0, limit = 0xFFFFF (1048575)1111 1111 1111 1111 1111 
|0x0000ffff|0000 0000 0000 0000 1111 1111 1111 1111|type = 0010, 数据段的TYPE为：0010（只读，向下扩展）
|----------|---------------------------------------|

S: 1
DPL: 00
P: 1
AVL: 0
L: 0
D/B = 1
G = 1

可以看到此时GDT里面的base是0，即基址为0

也就是说在刚开始

第一阶段
这一阶段是从bootasm.S的start到entry.S的kern_entry前，这个阶段很简单， 和lab1一样(这时的GDT中每个段的起始地址都是0x00000000并且此时kernel还没有载入)。
此时GDT里面的base是0，即基址为0
virt addr = linear addr = phy addr

0x7c68  ljmp   $0x8,$0x7c6d    
ljmp $KERNEL_CS, $relocated                                                                               │

设置CS为 KERNEL_CS = 0x8 = 1000 =  00001|0|00 -> Index = 1, GDT, RPL = 0 

relocated:
0x7c6d

eax            0x11     17
ecx            0x14     20
edx            0x534d4150       1397571920
ebx            0x0      0
esp            0x6f2c   0x6f2c
ebp            0x0      0x0
esi            0x0      0
edi            0x807c   32892
eip            0x7c6d   0x7c6d
eflags         0x6      [ PF ]
cs             0x8      8
ss             0x0      0
ds             0x0      0
es             0x0      0
fs             0x0      0
gs             0x0      0



第二阶段在kern_entry到enable_pagging
执行完：lgdt REALLOC(__gdtdesc)
GDT 0010C000 00000017
IDT 00000000 000003FF

eax            0x100000 1048576
ecx            0x0      0
edx            0x1f0    496
ebx            0x10074  65652
esp            0x7bcc   0x7bcc
ebp            0x7bf8   0x7bf8
esi            0x0      0
edi            0x1      1
eip            0x100007 0x100007
eflags         0x6      [ PF ]
cs             0x8      8
ss             0x10     16
ds             0x10     16
es             0x10     16
fs             0x10     16
gs             0x10     16



GDT
0x10c000:       0x00000000      0x00000000      0x0000ffff      0x40cf9a00
0x10c010:       0x0000ffff      0x40cf9200      0xc0000017      0x00000010
0x10c020:       0x00000001      0x00000000

可以看到全局描述符表一共三条：
|----------|---------------------------------------|
|0x00000000|0000 0000 0000 0000 0000 0000 0000 0000|按照x86的设计，第0项均为0
|0x00000000|0000 0000 0000 0000 0000 0000 0000 0000|
|----------|---------------------------------------|
|0x40cf9a00|0100 0000 1100 1111 1001 1010 0000 0000|base = 0x40000000(1073741824)0100 0000 0000 0000 0000 0000 0000 0000, limit = 0xFFFFF (1048575)1111 1111 1111 1111 1111
|0x0000ffff|0000 0000 0000 0000 1111 1111 1111 1111|type = 1010, 代码段的TYPE为：1010（执行、读）
|----------|---------------------------------------|
|0x40cf9200|0100 0000 1100 1111 1001 0010 0000 0000|base = 0x40000000(1073741824)0100 0000 0000 0000 0000 0000 0000 0000, limit = 0xFFFFF (1048575)1111 1111 1111 1111 1111 
|0x0000ffff|0000 0000 0000 0000 1111 1111 1111 1111|type = 0010, 数据段的TYPE为：0010（只读，向下扩展）
|----------|---------------------------------------|

0100 0000 0000 0000 0000 0000 0000 0000


0x40000000+0xC0000000
    0100 0000 0000 0000 0000 0000 0000 0000
+   1100 0000 0000 0000 0000 0000 0000 0000
=   0000 0000 0000 0000 0000 0000 0000 0000
即虚拟地址（线性地址）->通过段机制映射->物理地址
v_addr + ldt_segment_base -> 物理地址
即virt addr - 0xC0000000 = linear addr = phy addr

eax            0x10     16
ecx            0x0      0
edx            0x1f0    496
ebx            0x10074  65652
esp            0x7bcc   0x7bcc
ebp            0x7bf8   0x7bf8
esi            0x0      0
edi            0x1      1
eip            0x100012 0x100012
eflags         0x6      [ PF ]
cs             0x8      8
ss             0x10     16
ds             0x10     16
es             0x10     16
fs             0x10     16
gs             0x10     16



call kern_init之后
eax            0x10     16
ecx            0x0      0
edx            0x1f0    496
ebx            0x10074  65652
esp            0x7bcc   0x7bcc
ebp            0x7bf8   0x7bf8
esi            0x0      0
edi            0x1      1
eip            0xc0100019       0xc0100019 <relocated>
eflags         0x6      [ PF ]
cs             0x8      8
ss             0x10     16
ds             0x10     16
es             0x10     16
fs             0x10     16
gs             0x10     16




0xc0100075
0x00100075







